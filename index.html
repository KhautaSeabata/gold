<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MT5 Deriv Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            overflow-x: hidden;
            height: 100vh;
        }
        
        /* MT5 Header */
        .mt5-header {
            background: #1C1C1E;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #2C2C2E;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .mt5-logo {
            font-size: 20px;
            font-weight: 700;
            color: #007AFF;
        }
        .account-info {
            display: flex;
            flex-direction: column;
        }
        .account-number {
            font-size: 11px;
            color: #8E8E93;
        }
        .account-balance {
            font-size: 14px;
            color: #30D158;
            font-weight: 600;
        }
        
        /* Bottom Navigation */
        .mt5-bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1C1C1E;
            display: flex;
            justify-content: space-around;
            padding: 8px 0 calc(8px + env(safe-area-inset-bottom));
            border-top: 1px solid #2C2C2E;
            z-index: 1000;
        }
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            flex: 1;
            padding: 4px;
            color: #8E8E93;
            transition: color 0.2s;
        }
        .nav-item.active {
            color: #007AFF;
        }
        .nav-icon {
            font-size: 26px;
        }
        .nav-label {
            font-size: 10px;
        }
        
        /* Pages */
        .page-container {
            display: none;
            height: calc(100vh - 140px);
            overflow-y: auto;
        }
        .page-container.active {
            display: block;
        }
        
        /* Charts Page */
        .chart-toolbar {
            background: #1C1C1E;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            overflow-x: auto;
            border-bottom: 1px solid #2C2C2E;
        }
        .chart-toolbar::-webkit-scrollbar {
            display: none;
        }
        .toolbar-select {
            background: #2C2C2E;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            outline: none;
        }
        .toolbar-btn {
            background: #2C2C2E;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            white-space: nowrap;
            cursor: pointer;
        }
        .toolbar-btn.active {
            background: #007AFF;
        }
        
        .chart-view {
            position: relative;
            height: calc(100vh - 260px);
            background: #000;
        }
        .single-chart {
            display: none;
            height: 100%;
            flex-direction: column;
        }
        .single-chart.active {
            display: flex;
        }
        
        .chart-info-bar {
            background: #1C1C1E;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            border-bottom: 1px solid #2C2C2E;
        }
        .info-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .info-label {
            color: #8E8E93;
        }
        .info-value {
            font-weight: 600;
            font-size: 13px;
        }
        
        .chart-canvas-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .zoom-controls {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 20px;
            border: none;
            background: rgba(28, 28, 30, 0.8);
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }
        
        .chart-tabs {
            background: #1C1C1E;
            display: flex;
            overflow-x: auto;
            border-top: 1px solid #2C2C2E;
            padding: 0 15px;
        }
        .chart-tabs::-webkit-scrollbar {
            display: none;
        }
        .chart-tab {
            padding: 12px 20px;
            cursor: pointer;
            color: #8E8E93;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            font-size: 14px;
        }
        .chart-tab.active {
            color: #007AFF;
            border-bottom-color: #007AFF;
        }
        
        /* Signals Page */
        .signals-header {
            background: #1C1C1E;
            padding: 15px;
            border-bottom: 1px solid #2C2C2E;
        }
        .signals-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 10px;
        }
        .signals-controls {
            display: flex;
            gap: 10px;
        }
        .signal-filter-btn {
            padding: 6px 12px;
            background: #2C2C2E;
            border: none;
            color: white;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }
        .signal-filter-btn.active {
            background: #007AFF;
        }
        
        .signals-list {
            padding: 15px;
        }
        .signal-card {
            background: #1C1C1E;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 4px solid #007AFF;
        }
        .signal-card.bullish {
            border-left-color: #30D158;
        }
        .signal-card.bearish {
            border-left-color: #FF453A;
        }
        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .signal-name {
            font-size: 16px;
            font-weight: 600;
        }
        .signal-badge {
            background: rgba(0, 122, 255, 0.2);
            color: #007AFF;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
        }
        .signal-badge.bullish {
            background: rgba(48, 209, 88, 0.2);
            color: #30D158;
        }
        .signal-badge.bearish {
            background: rgba(255, 69, 58, 0.2);
            color: #FF453A;
        }
        .signal-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        .signal-detail {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
        }
        .detail-label {
            color: #8E8E93;
        }
        .detail-value {
            font-weight: 600;
        }
        .confidence-bar {
            height: 4px;
            background: #2C2C2E;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        .confidence-fill {
            height: 100%;
            background: #007AFF;
            transition: width 0.3s;
        }
        .confidence-fill.high {
            background: #30D158;
        }
        .signal-time {
            font-size: 11px;
            color: #8E8E93;
            margin-top: 8px;
        }
        
        .no-signals {
            text-align: center;
            padding: 60px 20px;
            color: #8E8E93;
        }
        .no-signals-icon {
            font-size: 60px;
            margin-bottom: 15px;
        }
        
        /* Settings Page */
        .settings-section {
            background: #1C1C1E;
            margin: 15px;
            border-radius: 12px;
            overflow: hidden;
        }
        .settings-item {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2C2C2E;
        }
        .settings-item:last-child {
            border-bottom: none;
        }
        .settings-label {
            font-size: 15px;
        }
        .settings-value {
            color: #8E8E93;
            font-size: 14px;
        }
        .toggle-switch {
            width: 50px;
            height: 30px;
            background: #2C2C2E;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active {
            background: #30D158;
        }
        .toggle-thumb {
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 13px;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        .toggle-switch.active .toggle-thumb {
            left: 22px;
        }
        
        .green { color: #30D158; }
        .red { color: #FF453A; }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 4px;
            margin-right: 6px;
        }
        .status-connected {
            background: #30D158;
        }
        .status-disconnected {
            background: #FF453A;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="mt5-header">
        <div class="header-left">
            <div class="mt5-logo">MT5</div>
            <div class="account-info">
                <div class="account-number">Demo #1234567</div>
                <div class="account-balance">$10,000.00</div>
            </div>
        </div>
        <div id="connectionStatus">
            <span class="status-indicator status-disconnected"></span>
        </div>
    </div>

    <!-- Charts Page -->
    <div class="page-container active" id="chartsPage">
        <!-- Toolbar -->
        <div class="chart-toolbar">
            <select class="toolbar-select" id="numCharts" onchange="changeNumCharts()">
                <option value="1">1 Chart</option>
                <option value="2">2 Charts</option>
                <option value="3">3 Charts</option>
                <option value="4" selected>4 Charts</option>
            </select>
            <button class="toolbar-btn" onclick="startAllCharts()">‚ñ∂ Start</button>
            <button class="toolbar-btn" onclick="stopAllCharts()">‚è∏ Stop</button>
            <button class="toolbar-btn" onclick="refreshAllCharts()">üîÑ</button>
            <button class="toolbar-btn" id="analysisToggle" onclick="toggleAnalysis()">üìä ON</button>
        </div>

        <!-- Chart View -->
        <div class="chart-view">
            <!-- Chart 1 -->
            <div class="single-chart active" id="chart1">
                <div class="chart-info-bar">
                    <div class="info-item">
                        <div class="info-label">Symbol</div>
                        <div class="info-value" id="symbolName1">Vol 25</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Price</div>
                        <div class="info-value" id="price1">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Change</div>
                        <div class="info-value" id="change1">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">H/L</div>
                        <div class="info-value" id="highlow1">--</div>
                    </div>
                </div>
                <div class="chart-toolbar">
                    <select class="toolbar-select" id="symbol1" onchange="updateChart(1)">
                        <option value="R_10">Vol 10</option>
                        <option value="R_25" selected>Vol 25</option>
                        <option value="R_50">Vol 50</option>
                        <option value="R_75">Vol 75</option>
                        <option value="R_100">Vol 100</option>
                    </select>
                    <select class="toolbar-select" id="timeframe1" onchange="updateChart(1)">
                        <option value="60" selected>1M</option>
                        <option value="300">5M</option>
                        <option value="900">15M</option>
                        <option value="1800">30M</option>
                        <option value="3600">1H</option>
                    </select>
                </div>
                <div class="chart-canvas-container">
                    <canvas id="canvas1"></canvas>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoom(1, 'in')">+</button>
                        <button class="zoom-btn" onclick="zoom(1, 'out')">‚àí</button>
                    </div>
                </div>
            </div>

            <!-- Chart 2 -->
            <div class="single-chart" id="chart2">
                <div class="chart-info-bar">
                    <div class="info-item">
                        <div class="info-label">Symbol</div>
                        <div class="info-value" id="symbolName2">Vol 50</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Price</div>
                        <div class="info-value" id="price2">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Change</div>
                        <div class="info-value" id="change2">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">H/L</div>
                        <div class="info-value" id="highlow2">--</div>
                    </div>
                </div>
                <div class="chart-toolbar">
                    <select class="toolbar-select" id="symbol2" onchange="updateChart(2)">
                        <option value="R_10">Vol 10</option>
                        <option value="R_25">Vol 25</option>
                        <option value="R_50" selected>Vol 50</option>
                        <option value="R_75">Vol 75</option>
                        <option value="R_100">Vol 100</option>
                    </select>
                    <select class="toolbar-select" id="timeframe2" onchange="updateChart(2)">
                        <option value="60">1M</option>
                        <option value="300" selected>5M</option>
                        <option value="900">15M</option>
                        <option value="1800">30M</option>
                        <option value="3600">1H</option>
                    </select>
                </div>
                <div class="chart-canvas-container">
                    <canvas id="canvas2"></canvas>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoom(2, 'in')">+</button>
                        <button class="zoom-btn" onclick="zoom(2, 'out')">‚àí</button>
                    </div>
                </div>
            </div>

            <!-- Chart 3 -->
            <div class="single-chart" id="chart3">
                <div class="chart-info-bar">
                    <div class="info-item">
                        <div class="info-label">Symbol</div>
                        <div class="info-value" id="symbolName3">Vol 75</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Price</div>
                        <div class="info-value" id="price3">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Change</div>
                        <div class="info-value" id="change3">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">H/L</div>
                        <div class="info-value" id="highlow3">--</div>
                    </div>
                </div>
                <div class="chart-toolbar">
                    <select class="toolbar-select" id="symbol3" onchange="updateChart(3)">
                        <option value="R_10">Vol 10</option>
                        <option value="R_25">Vol 25</option>
                        <option value="R_50">Vol 50</option>
                        <option value="R_75" selected>Vol 75</option>
                        <option value="R_100">Vol 100</option>
                    </select>
                    <select class="toolbar-select" id="timeframe3" onchange="updateChart(3)">
                        <option value="60">1M</option>
                        <option value="300">5M</option>
                        <option value="900" selected>15M</option>
                        <option value="1800">30M</option>
                        <option value="3600">1H</option>
                    </select>
                </div>
                <div class="chart-canvas-container">
                    <canvas id="canvas3"></canvas>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoom(3, 'in')">+</button>
                        <button class="zoom-btn" onclick="zoom(3, 'out')">‚àí</button>
                    </div>
                </div>
            </div>

            <!-- Chart 4 -->
            <div class="single-chart" id="chart4">
                <div class="chart-info-bar">
                    <div class="info-item">
                        <div class="info-label">Symbol</div>
                        <div class="info-value" id="symbolName4">Vol 100</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Price</div>
                        <div class="info-value" id="price4">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Change</div>
                        <div class="info-value" id="change4">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">H/L</div>
                        <div class="info-value" id="highlow4">--</div>
                    </div>
                </div>
                <div class="chart-toolbar">
                    <select class="toolbar-select" id="symbol4" onchange="updateChart(4)">
                        <option value="R_10">Vol 10</option>
                        <option value="R_25">Vol 25</option>
                        <option value="R_50">Vol 50</option>
                        <option value="R_75">Vol 75</option>
                        <option value="R_100" selected>Vol 100</option>
                    </select>
                    <select class="toolbar-select" id="timeframe4" onchange="updateChart(4)">
                        <option value="60">1M</option>
                        <option value="300">5M</option>
                        <option value="900">15M</option>
                        <option value="1800" selected>30M</option>
                        <option value="3600">1H</option>
                    </select>
                </div>
                <div class="chart-canvas-container">
                    <canvas id="canvas4"></canvas>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoom(4, 'in')">+</button>
                        <button class="zoom-btn" onclick="zoom(4, 'out')">‚àí</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chart Tabs -->
        <div class="chart-tabs" id="chartTabs">
            <div class="chart-tab active" onclick="switchChart(1)">Chart 1</div>
            <div class="chart-tab" onclick="switchChart(2)">Chart 2</div>
            <div class="chart-tab" onclick="switchChart(3)">Chart 3</div>
            <div class="chart-tab" onclick="switchChart(4)">Chart 4</div>
        </div>
    </div>

    <!-- Signals Page -->
    <div class="page-container" id="signalsPage">
        <div class="signals-header">
            <div class="signals-title">Trading Signals</div>
            <div class="signals-controls">
                <button class="signal-filter-btn active" onclick="filterSignals('all')">All</button>
                <button class="signal-filter-btn" onclick="filterSignals('bullish')">Bullish</button>
                <button class="signal-filter-btn" onclick="filterSignals('bearish')">Bearish</button>
            </div>
        </div>
        <div class="signals-list" id="signalsList">
            <div class="no-signals">
                <div class="no-signals-icon">üìä</div>
                <div>No signals detected yet</div>
                <div style="font-size: 12px; margin-top: 8px;">Start charts to detect patterns</div>
            </div>
        </div>
    </div>

    <!-- Settings Page -->
    <div class="page-container" id="settingsPage">
        <div class="settings-section">
            <div class="settings-item">
                <div class="settings-label">Pattern Analysis</div>
                <div class="toggle-switch active" onclick="toggleSetting(this)">
                    <div class="toggle-thumb"></div>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-label">Sound Alerts</div>
                <div class="toggle-switch active" onclick="toggleSetting(this)">
                    <div class="toggle-thumb"></div>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-label">Push Notifications</div>
                <div class="toggle-switch" onclick="toggleSetting(this)">
                    <div class="toggle-thumb"></div>
                </div>
            </div>
        </div>
        <div class="settings-section" style="margin-top: 20px;">
            <div class="settings-item">
                <div class="settings-label">Clear All Signals</div>
                <button class="toolbar-btn" onclick="clearAllSignals()" style="background: #FF453A;">Clear</button>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div class="mt5-bottom-nav">
        <div class="nav-item active" onclick="switchPage('chartsPage')">
            <div class="nav-icon">üìà</div>
            <div class="nav-label">Charts</div>
        </div>
        <div class="nav-item" onclick="switchPage('signalsPage')">
            <div class="nav-icon">üéØ</div>
            <div class="nav-label">Signals</div>
        </div>
        <div class="nav-item" onclick="switchPage('settingsPage')">
            <div class="nav-icon">‚öôÔ∏è</div>
            <div class="nav-label">Settings</div>
        </div>
    </div>

    <script>
        const FIREBASE_URL = 'https://alerts-83c9b-default-rtdb.firebaseio.com';
        
        let charts = {};
        let currentChartView = 1;
        let numActiveCharts = 4;
        let analysisEnabled = true;
        let allSignals = [];
        let signalFilter = 'all';

        class ChartManager {
            constructor(id) {
                this.id = id;
                this.canvas = document.getElementById(`canvas${id}`);
                this.ctx = this.canvas.getContext('2d');
                this.data = [];
                this.ws = null;
                this.symbol = document.getElementById(`symbol${id}`).value;
                this.timeframe = parseInt(document.getElementById(`timeframe${id}`).value);
                this.zoom = 80;
                this.offset = 0;
                this.dragging = false;
                this.autoScroll = true;
                this.analysis = {};
                
                this.resizeCanvas();
                this.setupDrag();
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }

            setupDrag() {
                let startX, startOffset;
                this.canvas.addEventListener('touchstart', (e) => {
                    this.dragging = true;
                    startX = e.touches[0].clientX;
                    startOffset = this.offset;
                    this.autoScroll = false;
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    if (!this.dragging) return;
                    const deltaX = e.touches[0].clientX - startX;
                    const candlesPerScreen = Math.floor(this.zoom);
                    const pixelsPerCandle = this.canvas.width / candlesPerScreen;
                    const candlesDelta = Math.round(deltaX / pixelsPerCandle);
                    this.offset = Math.max(0, Math.min(this.data.length - candlesPerScreen, startOffset - candlesDelta));
                    this.draw();
                });
                this.canvas.addEventListener('touchend', () => {
                    this.dragging = false;
                    if (this.offset >= this.data.length - this.zoom - 5) {
                        this.autoScroll = true;
                    }
                });
            }

            connect() {
                if (this.ws) this.ws.close();
                
                this.ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
                
                this.ws.onopen = () => {
                    updateConnectionStatus(true);
                    this.ws.send(JSON.stringify({ ticks: this.symbol, subscribe: 1 }));
                    this.ws.send(JSON.stringify({
                        ticks_history: this.symbol,
                        count: 1000,
                        end: 'latest',
                        style: 'candles',
                        granularity: this.timeframe
                    }));
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.candles) {
                        this.data = data.candles.map(c => ({
                            x: c.epoch * 1000,
                            o: parseFloat(c.open),
                            h: parseFloat(c.high),
                            l: parseFloat(c.low),
                            c: parseFloat(c.close)
                        }));
                        this.draw();
                        this.updateInfo();
                        if (analysisEnabled) this.analyze();
                    } else if (data.tick) {
                        this.updateTick(parseFloat(data.tick.quote), data.tick.epoch * 1000);
                    }
                };

                this.ws.onerror = () => updateConnectionStatus(false);
                this.ws.onclose = () => updateConnectionStatus(false);
            }

            updateTick(price, time) {
                                const candleStart = Math.floor(time / (this.timeframe * 1000)) * (this.timeframe * 1000);
                
                if (!this.data.length || candleStart > this.data[this.data.length - 1].x) {
                    this.data.push({ x: candleStart, o: price, h: price, l: price, c: price });
                    if (this.data.length > 1000) this.data.shift();
                    if (analysisEnabled) this.analyze();
                } else {
                    const last = this.data[this.data.length - 1];
                    last.c = price;
                    last.h = Math.max(last.h, price);
                    last.l = Math.min(last.l, price);
                }
                
                this.draw();
                this.updateInfo();
            }

            analyze() {
                if (this.data.length < 30) return;
                
                // Full technical analysis
                this.analysis = {
                    supportResistance: this.findSupportResistance(),
                    trendlines: this.findTrendlines(),
                    momentum: this.calculateMomentum(),
                    patterns: []
                };
                
                // Detect all patterns
                this.detectTriangle('symmetrical');
                this.detectTriangle('ascending');
                this.detectTriangle('descending');
                this.detectHeadAndShoulders(false);
                this.detectHeadAndShoulders(true);
                this.detectDoubleTopBottom('top');
                this.detectDoubleTopBottom('bottom');
                this.detectWedge('rising');
                this.detectWedge('falling');
                
                this.draw();
            }

            findSupportResistance() {
                const levels = [];
                const recent = this.data.slice(-100);
                const highs = recent.map(c => c.h);
                const lows = recent.map(c => c.l);
                
                // Major levels
                const resistance = Math.max(...highs.slice(-20));
                const support = Math.min(...lows.slice(-20));
                
                levels.push({ type: 'resistance', price: resistance, strength: 90 });
                levels.push({ type: 'support', price: support, strength: 90 });
                
                // Pivot levels
                for (let i = 3; i < recent.length - 3; i++) {
                    if (highs[i] > highs[i-1] && highs[i] > highs[i-2] && highs[i] > highs[i-3] &&
                        highs[i] > highs[i+1] && highs[i] > highs[i+2] && highs[i] > highs[i+3]) {
                        levels.push({ type: 'resistance', price: highs[i], strength: 75 });
                    }
                    if (lows[i] < lows[i-1] && lows[i] < lows[i-2] && lows[i] < lows[i-3] &&
                        lows[i] < lows[i+1] && lows[i] < lows[i+2] && lows[i] < lows[i+3]) {
                        levels.push({ type: 'support', price: lows[i], strength: 75 });
                    }
                }
                
                return levels.slice(-6);
            }

            findTrendlines() {
                const trendlines = [];
                const recent = this.data.slice(-100);
                const highs = recent.map(c => c.h);
                const lows = recent.map(c => c.l);
                
                const peaks = this.findPeaks(highs);
                const troughs = this.findTroughs(lows);
                
                if (peaks.length >= 2) {
                    const recentPeaks = peaks.slice(-3);
                    const points = recentPeaks.map(idx => ({ 
                        idx: idx, 
                        x: recent[idx].x, 
                        y: highs[idx] 
                    }));
                    const slope = this.calculateSlope(recentPeaks.map((p, i) => [i, highs[p]]));
                    trendlines.push({ 
                        type: 'resistance',
                        points: points,
                        slope: slope,
                        label: slope > 0 ? 'Rising Resistance' : 'Falling Resistance'
                    });
                }
                
                if (troughs.length >= 2) {
                    const recentTroughs = troughs.slice(-3);
                    const points = recentTroughs.map(idx => ({ 
                        idx: idx, 
                        x: recent[idx].x, 
                        y: lows[idx] 
                    }));
                    const slope = this.calculateSlope(recentTroughs.map((t, i) => [i, lows[t]]));
                    trendlines.push({ 
                        type: 'support',
                        points: points,
                        slope: slope,
                        label: slope > 0 ? 'Rising Support' : 'Falling Support'
                    });
                }
                
                return trendlines;
            }

            calculateMomentum() {
                const recent = this.data.slice(-14);
                const closes = recent.map(c => c.c);
                
                let gains = 0, losses = 0;
                for (let i = 1; i < closes.length; i++) {
                    const change = closes[i] - closes[i-1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                
                const rs = gains / (losses || 1);
                const rsi = 100 - (100 / (1 + rs));
                
                const macd = this.calculateMACD();
                
                let signal = 'neutral';
                if (rsi > 70) signal = 'overbought';
                else if (rsi < 30) signal = 'oversold';
                else if (rsi > 50 && macd > 0) signal = 'bullish';
                else if (rsi < 50 && macd < 0) signal = 'bearish';
                
                return { rsi: rsi.toFixed(1), macd: macd.toFixed(4), signal: signal };
            }

            calculateMACD() {
                const closes = this.data.slice(-26).map(c => c.c);
                const ema12 = this.calculateEMA(closes, 12);
                const ema26 = this.calculateEMA(closes, 26);
                return ema12 - ema26;
            }

            calculateEMA(data, period) {
                const k = 2 / (period + 1);
                let ema = data[0];
                for (let i = 1; i < data.length; i++) {
                    ema = data[i] * k + ema * (1 - k);
                }
                return ema;
            }

            detectTriangle(type) {
                const recent = this.data.slice(-50);
                if (recent.length < 20) return;
                
                const highs = recent.map(c => c.h);
                const lows = recent.map(c => c.l);
                const peaks = this.findPeaks(highs);
                const troughs = this.findTroughs(lows);
                
                if (peaks.length < 2 || troughs.length < 2) return;
                
                const recentPeaks = peaks.slice(-3);
                const recentTroughs = troughs.slice(-3);
                const upperSlope = this.calculateSlope(recentPeaks.map((p, i) => [i, highs[p]]));
                const lowerSlope = this.calculateSlope(recentTroughs.map((t, i) => [i, lows[t]]));
                
                let isPattern = false;
                let bias = 'neutral';
                
                if (type === 'symmetrical' && upperSlope < -0.001 && lowerSlope > 0.001) {
                    isPattern = true;
                    bias = this.determineTrendBias();
                } else if (type === 'ascending' && Math.abs(upperSlope) < 0.002 && lowerSlope > 0.001) {
                    isPattern = true;
                    bias = 'bullish';
                } else if (type === 'descending' && upperSlope < -0.001 && Math.abs(lowerSlope) < 0.002) {
                    isPattern = true;
                    bias = 'bearish';
                }
                
                if (isPattern) {
                    const pattern = this.createPatternSignal(
                        `${type.charAt(0).toUpperCase() + type.slice(1)} Triangle`,
                        bias
                    );
                    pattern.visualData = {
                        type: 'triangle',
                        upperPoints: recentPeaks.map(i => ({ idx: i, y: highs[i] })),
                        lowerPoints: recentTroughs.map(i => ({ idx: i, y: lows[i] }))
                    };
                    this.analysis.patterns.push(pattern);
                    addSignal(pattern);
                }
            }

            detectHeadAndShoulders(inverse = false) {
                const recent = this.data.slice(-50);
                if (recent.length < 25) return;
                
                const prices = inverse ? recent.map(c => c.l) : recent.map(c => c.h);
                const extremes = inverse ? this.findTroughs(prices) : this.findPeaks(prices);
                
                if (extremes.length < 5) return;
                
                const pts = extremes.slice(-5);
                if (pts.length === 5) {
                    const [ls, lh, head, rh, rs] = pts.map(i => prices[i]);
                    const headHigher = inverse ? (head < ls && head < rs) : (head > ls && head > rs);
                    const shouldersLevel = Math.abs(ls - rs) / ls < 0.02;
                    
                    if (headHigher && shouldersLevel) {
                        const pattern = this.createPatternSignal(
                            inverse ? 'Inverse Head & Shoulders' : 'Head & Shoulders',
                            inverse ? 'bullish' : 'bearish'
                        );
                        pattern.visualData = {
                            type: 'headshoulders',
                            points: pts.map(i => ({ idx: i, y: prices[i] })),
                            inverse: inverse
                        };
                        this.analysis.patterns.push(pattern);
                        addSignal(pattern);
                    }
                }
            }

            detectDoubleTopBottom(type) {
                const recent = this.data.slice(-50);
                if (recent.length < 20) return;
                
                const prices = type === 'top' ? recent.map(c => c.h) : recent.map(c => c.l);
                const extremes = type === 'top' ? this.findPeaks(prices) : this.findTroughs(prices);
                
                if (extremes.length < 2) return;
                
                const pts = extremes.slice(-2);
                const [first, second] = pts.map(i => prices[i]);
                const similarity = Math.abs(first - second) / first;
                
                if (similarity < 0.015) {
                    const pattern = this.createPatternSignal(
                        `Double ${type.charAt(0).toUpperCase() + type.slice(1)}`,
                        type === 'top' ? 'bearish' : 'bullish'
                    );
                    pattern.visualData = {
                        type: 'double',
                        points: pts.map(i => ({ idx: i, y: prices[i] })),
                        isTop: type === 'top'
                    };
                    this.analysis.patterns.push(pattern);
                    addSignal(pattern);
                }
            }

            detectWedge(type) {
                const recent = this.data.slice(-50);
                if (recent.length < 20) return;
                
                const highs = recent.map(c => c.h);
                const lows = recent.map(c => c.l);
                const peaks = this.findPeaks(highs);
                const troughs = this.findTroughs(lows);
                
                if (peaks.length < 2 || troughs.length < 2) return;
                
                const recentPeaks = peaks.slice(-3);
                const recentTroughs = troughs.slice(-3);
                const upperSlope = this.calculateSlope(recentPeaks.map((p, i) => [i, highs[p]]));
                const lowerSlope = this.calculateSlope(recentTroughs.map((t, i) => [i, lows[t]]));
                
                let isPattern = false;
                let bias = 'neutral';
                
                if (type === 'rising' && upperSlope > 0.001 && lowerSlope > 0.001 && lowerSlope > upperSlope) {
                    isPattern = true;
                    bias = 'bearish';
                } else if (type === 'falling' && upperSlope < -0.001 && lowerSlope < -0.001 && upperSlope < lowerSlope) {
                    isPattern = true;
                    bias = 'bullish';
                }
                
                if (isPattern) {
                    const pattern = this.createPatternSignal(
                        `${type.charAt(0).toUpperCase() + type.slice(1)} Wedge`,
                        bias
                    );
                    pattern.visualData = {
                        type: 'wedge',
                        upperPoints: recentPeaks.map(i => ({ idx: i, y: highs[i] })),
                        lowerPoints: recentTroughs.map(i => ({ idx: i, y: lows[i] }))
                    };
                    this.analysis.patterns.push(pattern);
                    addSignal(pattern);
                }
            }

            findPeaks(prices) {
                const peaks = [];
                for (let i = 2; i < prices.length - 2; i++) {
                    if (prices[i] > prices[i-1] && prices[i] > prices[i-2] &&
                        prices[i] > prices[i+1] && prices[i] > prices[i+2]) {
                        peaks.push(i);
                    }
                }
                return peaks;
            }

            findTroughs(prices) {
                const troughs = [];
                for (let i = 2; i < prices.length - 2; i++) {
                    if (prices[i] < prices[i-1] && prices[i] < prices[i-2] &&
                        prices[i] < prices[i+1] && prices[i] < prices[i+2]) {
                        troughs.push(i);
                    }
                }
                return troughs;
            }

            calculateSlope(points) {
                if (points.length < 2) return 0;
                const n = points.length;
                const sumX = points.reduce((sum, p) => sum + p[0], 0);
                const sumY = points.reduce((sum, p) => sum + p[1], 0);
                const sumXY = points.reduce((sum, p) => sum + p[0] * p[1], 0);
                const sumX2 = points.reduce((sum, p) => sum + p[0] * p[0], 0);
                return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            }

            determineTrendBias() {
                const recent = this.data.slice(-20);
                const startPrice = recent[0].o;
                const endPrice = recent[recent.length - 1].c;
                return endPrice > startPrice ? 'bullish' : 'bearish';
            }

            createPatternSignal(patternName, bias) {
                const currentPrice = this.data[this.data.length - 1].c;
                const pipValue = 0.001;
                let entry, tp1, tp2, tp3, sl;
                
                if (bias === 'bullish') {
                    entry = currentPrice * 1.0001;
                    tp1 = entry + (10 * pipValue);
                    tp2 = entry + (20 * pipValue);
                    tp3 = entry + (30 * pipValue);
                    sl = entry - (15 * pipValue);
                } else if (bias === 'bearish') {
                    entry = currentPrice * 0.9999;
                    tp1 = entry - (10 * pipValue);
                    tp2 = entry - (20 * pipValue);
                    tp3 = entry - (30 * pipValue);
                    sl = entry + (15 * pipValue);
                } else {
                    entry = currentPrice;
                    tp1 = currentPrice + (10 * pipValue);
                    tp2 = currentPrice + (20 * pipValue);
                    tp3 = currentPrice + (30 * pipValue);
                    sl = currentPrice - (15 * pipValue);
                }
                
                return {
                    id: Date.now() + Math.random(),
                    chartId: this.id,
                    name: patternName,
                    bias: bias,
                    timeframe: this.timeframe,
                    entry: entry.toFixed(5),
                    tp1: tp1.toFixed(5),
                    tp2: tp2.toFixed(5),
                    tp3: tp3.toFixed(5),
                    sl: sl.toFixed(5),
                    confidence: this.calculateConfidence(bias),
                    timestamp: Date.now()
                };
            }

            calculateConfidence(bias) {
                const recent = this.data.slice(-10);
                let confirming = 0;
                for (let i = 1; i < recent.length; i++) {
                    if (bias === 'bullish' && recent[i].c > recent[i-1].c) confirming++;
                    if (bias === 'bearish' && recent[i].c < recent[i-1].c) confirming++;
                }
                let confidence = (confirming / (recent.length - 1)) * 100;
                return Math.min(100, Math.round(confidence));
            }

            draw() {
                if (!this.data.length) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const padding = { top: 20, right: 10, bottom: 20, left: 50 };
                const chartW = this.canvas.width - padding.left - padding.right;
                const chartH = this.canvas.height - padding.top - padding.bottom;
                
                const candlesPerScreen = Math.floor(this.zoom);
                if (this.autoScroll) {
                    this.offset = Math.max(0, this.data.length - candlesPerScreen);
                }
                
                const visible = this.data.slice(this.offset, this.offset + candlesPerScreen);
                if (!visible.length) return;
                
                const prices = visible.flatMap(c => [c.h, c.l]);
                const maxP = Math.max(...prices);
                const minP = Math.min(...prices);
                const range = maxP - minP;
                const pad = range * 0.1;
                
                const candleW = Math.max(2, Math.min(12, chartW / visible.length - 2));
                const spacing = chartW / visible.length;
                
                // Helper function to convert price to Y coordinate
                const priceToY = (price) => {
                    return padding.top + ((maxP + pad - price) / (range + pad * 2)) * chartH;
                };
                
                // Helper function to convert data index to X coordinate
                const indexToX = (idx) => {
                    const visibleIdx = idx - this.offset;
                    return padding.left + spacing * visibleIdx + spacing / 2;
                };
                
                // Draw grid
                this.ctx.strokeStyle = '#2C2C2E';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (chartH / 4) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding.left, y);
                    this.ctx.lineTo(this.canvas.width - padding.right, y);
                    this.ctx.stroke();
                    
                    const price = maxP + pad - (range + pad * 2) * (i / 4);
                    this.ctx.fillStyle = '#8E8E93';
                    this.ctx.font = '10px Arial';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(price.toFixed(2), padding.left - 5, y + 3);
                }
                
                // Draw analysis if enabled
                if (analysisEnabled && this.analysis) {
                    // Draw support/resistance levels
                    if (this.analysis.supportResistance) {
                        this.analysis.supportResistance.forEach(level => {
                            const y = priceToY(level.price);
                            this.ctx.save();
                            this.ctx.strokeStyle = level.type === 'resistance' ? '#FF453A' : '#30D158';
                            this.ctx.lineWidth = 1.5;
                            this.ctx.setLineDash([8, 4]);
                            this.ctx.globalAlpha = 0.7;
                            this.ctx.beginPath();
                            this.ctx.moveTo(padding.left, y);
                            this.ctx.lineTo(this.canvas.width - padding.right, y);
                            this.ctx.stroke();
                            
                            this.ctx.fillStyle = level.type === 'resistance' ? '#FF453A' : '#30D158';
                            this.ctx.globalAlpha = 1;
                            this.ctx.font = 'bold 9px Arial';
                            this.ctx.textAlign = 'left';
                            this.ctx.fillText(level.price.toFixed(2), padding.left + 5, y - 3);
                            this.ctx.restore();
                        });
                    }
                    
                    // Draw trendlines
                    if (this.analysis.trendlines) {
                        this.analysis.trendlines.forEach(tl => {
                            this.ctx.save();
                            this.ctx.strokeStyle = tl.type === 'resistance' ? '#FF9F0A' : '#007AFF';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([6, 3]);
                            this.ctx.globalAlpha = 0.8;
                            this.ctx.beginPath();
                            
                            tl.points.forEach((point, i) => {
                                const globalIdx = this.data.findIndex(d => Math.abs(d.x - point.x) < 30000);
                                if (globalIdx >= this.offset && globalIdx < this.offset + candlesPerScreen) {
                                    const x = indexToX(globalIdx);
                                    const y = priceToY(point.y);
                                    if (i === 0) this.ctx.moveTo(x, y);
                                    else this.ctx.lineTo(x, y);
                                }
                            });
                            
                            this.ctx.stroke();
                            this.ctx.restore();
                        });
                    }
                    
                    // Draw pattern visualizations
                    if (this.analysis.patterns) {
                        this.analysis.patterns.forEach(pattern => {
                            if (!pattern.visualData) return;
                            
                            this.ctx.save();
                            
                            if (pattern.visualData.type === 'triangle' || pattern.visualData.type === 'wedge') {
                                // Draw upper and lower lines
                                this.ctx.strokeStyle = pattern.bias === 'bullish' ? '#30D158' : '#FF453A';
                                this.ctx.lineWidth = 2;
                                this.ctx.setLineDash([4, 4]);
                                this.ctx.globalAlpha = 0.6;
                                
                                // Upper line
                                this.ctx.beginPath();
                                pattern.visualData.upperPoints.forEach((point, i) => {
                                    const globalIdx = this.offset + point.idx;
                                    if (globalIdx >= this.offset && globalIdx < this.offset + candlesPerScreen) {
                                        const x = indexToX(globalIdx);
                                        const y = priceToY(point.y);
                                        if (i === 0) this.ctx.moveTo(x, y);
                                        else this.ctx.lineTo(x, y);
                                    }
                                });
                                this.ctx.stroke();
                                
                                // Lower line
                                this.ctx.beginPath();
                                pattern.visualData.lowerPoints.forEach((point, i) => {
                                    const globalIdx = this.offset + point.idx;
                                    if (globalIdx >= this.offset && globalIdx < this.offset + candlesPerScreen) {
                                        const x = indexToX(globalIdx);
                                        const y = priceToY(point.y);
                                        if (i === 0) this.ctx.moveTo(x, y);
                                        else this.ctx.lineTo(x, y);
                                    }
                                });
                                this.ctx.stroke();
                                
                            } else if (pattern.visualData.type === 'headshoulders') {
                                // Draw H&S pattern
                                this.ctx.strokeStyle = pattern.bias === 'bullish' ? '#30D158' : '#FF453A';
                                this.ctx.lineWidth = 2;
                                this.ctx.globalAlpha = 0.7;
                                
                                this.ctx.beginPath();
                                pattern.visualData.points.forEach((point, i) => {
                                    const globalIdx = this.offset + point.idx;
                                    if (globalIdx >= this.offset && globalIdx < this.offset + candlesPerScreen) {
                                        const x = indexToX(globalIdx);
                                        const y = priceToY(point.y);
                                        if (i === 0) this.ctx.moveTo(x, y);
                                        else this.ctx.lineTo(x, y);
                                        
                                        // Mark points
                                        this.ctx.fillStyle = pattern.bias === 'bullish' ? '#30D158' : '#FF453A';
                                        this.ctx.beginPath();
                                        this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                                        this.ctx.fill();
                                    }
                                });
                                this.ctx.stroke();
                                
                            } else if (pattern.visualData.type === 'double') {
                                // Draw double top/bottom
                                this.ctx.strokeStyle = pattern.bias === 'bullish' ? '#30D158' : '#FF453A';
                                this.ctx.lineWidth = 2;
                                this.ctx.globalAlpha = 0.7;
                                
                                pattern.visualData.points.forEach(point => {
                                    const globalIdx = this.offset + point.idx;
                                    if (globalIdx >= this.offset && globalIdx < this.offset + candlesPerScreen) {
                                        const x = indexToX(globalIdx);
                                        const y = priceToY(point.y);
                                        
                                        this.ctx.fillStyle = pattern.bias === 'bullish' ? '#30D158' : '#FF453A';
                                        this.ctx.beginPath();
                                        this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                                        this.ctx.fill();
                                    }
                                });
                                
                                // Connect the two tops/bottoms
                                if (pattern.visualData.points.length === 2) {
                                    this.ctx.setLineDash([4, 4]);
                                    this.ctx.beginPath();
                                    const idx1 = this.offset + pattern.visualData.points[0].idx;
                                    const idx2 = this.offset + pattern.visualData.points[1].idx;
                                    if (idx1 >= this.offset && idx2 < this.offset + candlesPerScreen) {
                                        this.ctx.moveTo(indexToX(idx1), priceToY(pattern.visualData.points[0].y));
                                        this.ctx.lineTo(indexToX(idx2), priceToY(pattern.visualData.points[1].y));
                                        this.ctx.stroke();
                                    }
                                }
                            }
                            
                            this.ctx.restore();
                        });
                    }
                }
                
                // Draw candles
                visible.forEach((c, i) => {
                    const x = padding.left + spacing * i + spacing / 2;
                    const yH = priceToY(c.h);
                    const yL = priceToY(c.l);
                    const yO = priceToY(c.o);
                    const yC = priceToY(c.c);
                    
                    const isUp = c.c >= c.o;
                    const color = isUp ? '#30D158' : '#FF453A';
                    
                    // Wick
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = Math.max(1, candleW / 4);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, yH);
                    this.ctx.lineTo(x, yL);
                    this.ctx.stroke();
                    
                    // Body
                    this.ctx.fillStyle = color;
                    const bodyH = Math.max(Math.abs(yC - yO), 1);
                    this.ctx.fillRect(x - candleW / 2, Math.min(yO, yC), candleW, bodyH);
                });
                
                // Draw analysis info overlay
                if (analysisEnabled && this.analysis && this.analysis.momentum) {
                    this.ctx.save();
                    this.ctx.fillStyle = 'rgba(28, 28, 30, 0.9)';
                    this.ctx.fillRect(padding.left + 5, padding.top + 5, 150, 65);
                    
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText('üìä Analysis', padding.left + 10, padding.top + 18);
                    
                    this.ctx.font = '9px Arial';
                    this.ctx.fillStyle = '#8E8E93';
                    this.ctx.fillText(`RSI: ${this.analysis.momentum.rsi}`, padding.left + 10, padding.top + 32);
                    this.ctx.fillText(`MACD: ${this.analysis.momentum.macd}`, padding.left + 10, padding.top + 44);
                    
                    const signalColor = this.analysis.momentum.signal === 'bullish' ? '#30D158' :
                                       this.analysis.momentum.signal === 'bearish' ? '#FF453A' : '#FFCC00';
                    this.ctx.fillStyle = signalColor;
                    this.ctx.fillText(`Signal: ${this.analysis.momentum.signal.toUpperCase()}`, padding.left + 10, padding.top + 56);
                    
                    if (this.analysis.patterns && this.analysis.patterns.length > 0) {
                        this.ctx.fillStyle = '#007AFF';
                        this.ctx.fillText(`Patterns: ${this.analysis.patterns.length}`, padding.left + 10, padding.top + 65);
                    }
                    
                    this.ctx.restore();
                }
            }

            updateInfo() {
                if (!this.data.length) return;
                
                const current = this.data[this.data.length - 1];
                const first = this.data[0];
                const change = current.c - first.o;
                
                const prices = this.data.flatMap(c => [c.h, c.l]);
                const high = Math.max(...prices);
                const low = Math.min(...prices);
                
                document.getElementById(`price${this.id}`).textContent = current.c.toFixed(2);
                
                const changeEl = document.getElementById(`change${this.id}`);
                changeEl.innerHTML = `<span class="${change >= 0 ? 'green' : 'red'}">${change >= 0 ? '+' : ''}${change.toFixed(2)}</span>`;
                
                document.getElementById(`highlow${this.id}`).textContent = `${high.toFixed(2)}/${low.toFixed(2)}`;
            }

            disconnect() {
                if (this.ws) this.ws.close();
            }
        }

        // Initialize charts
        for (let i = 1; i <= 4; i++) {
            charts[i] = new ChartManager(i);
        }

        // Page switching
        function switchPage(pageId) {
            document.querySelectorAll('.page-container').forEach(p => p.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            
            document.querySelectorAll('.nav-item').forEach((item, idx) => {
                item.classList.remove('active');
                if ((pageId === 'chartsPage' && idx === 0) ||
                    (pageId === 'signalsPage' && idx === 1) ||
                    (pageId === 'settingsPage' && idx === 2)) {
                    item.classList.add('active');
                }
            });
            
            if (pageId === 'signalsPage') {
                displaySignals();
            }
        }

        // Chart switching
        function switchChart(chartId) {
            document.querySelectorAll('.single-chart').forEach(c => c.classList.remove('active'));
            document.getElementById(`chart${chartId}`).classList.add('active');
            
            document.querySelectorAll('.chart-tab').forEach((tab, idx) => {
                tab.classList.remove('active');
                if (idx === chartId - 1) tab.classList.add('active');
            });
            
            currentChartView = chartId;
            charts[chartId].resizeCanvas();
            charts[chartId].draw();
        }

        function changeNumCharts() {
            numActiveCharts = parseInt(document.getElementById('numCharts').value);
            const tabs = document.getElementById('chartTabs');
            tabs.innerHTML = '';
            for (let i = 1; i <= numActiveCharts; i++) {
                const tab = document.createElement('div');
                tab.className = `chart-tab ${i === 1 ? 'active' : ''}`;
                tab.textContent = `Chart ${i}`;
                tab.onclick = () => switchChart(i);
                tabs.appendChild(tab);
            }
            switchChart(1);
        }

        function updateChart(id) {
            const chart = charts[id];
            chart.symbol = document.getElementById(`symbol${id}`).value;
            chart.timeframe = parseInt(document.getElementById(`timeframe${id}`).value);
            
            const symbolEl = document.getElementById(`symbol${id}`);
            document.getElementById(`symbolName${id}`).textContent = symbolEl.options[symbolEl.selectedIndex].text;
            
            if (chart.ws && chart.ws.readyState === WebSocket.OPEN) {
                chart.disconnect();
                setTimeout(() => chart.connect(), 300);
            }
        }

        function zoom(id, dir) {
            const chart = charts[id];
            if (dir === 'in') {
                chart.zoom = Math.max(20, chart.zoom - 10);
            } else {
                chart.zoom = Math.min(150, chart.zoom + 10);
            }
            chart.draw();
        }

        function startAllCharts() {
            for (let i = 1; i <= numActiveCharts; i++) {
                charts[i].connect();
            }
        }

        function stopAllCharts() {
            for (let i = 1; i <= numActiveCharts; i++) {
                charts[i].disconnect();
            }
        }

        function refreshAllCharts() {
            stopAllCharts();
            setTimeout(() => startAllCharts(), 500);
        }

        function toggleAnalysis() {
            analysisEnabled = !analysisEnabled;
            const btn = document.getElementById('analysisToggle');
            btn.textContent = analysisEnabled ? 'üìä ON' : 'üìä OFF';
            btn.style.background = analysisEnabled ? '#007AFF' : '#2C2C2E';
        }

        function updateConnectionStatus(connected) {
            const indicator = document.querySelector('.status-indicator');
            indicator.className = `status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`;
        }

        // Signal management
        function addSignal(signal) {
            const exists = allSignals.find(s => 
                s.name === signal.name && 
                s.chartId === signal.chartId && 
                Date.now() - s.timestamp < 300000
            );
            
            if (!exists) {
                allSignals.unshift(signal);
                allSignals = allSignals.slice(0, 50);
                saveSignalToFirebase(signal);
                
                if (signal.confidence >= 85) {
                    playSound();
                    if ('Notification' in window && Notification.permission === 'granted') {
                        new Notification('High Confidence Signal!', {
                            body: `${signal.name} - ${signal.bias.toUpperCase()}`
                        });
                    }
                }
            }
        }

        async function saveSignalToFirebase(signal) {
            try {
                await fetch(`${FIREBASE_URL}/signals/${signal.id}.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(signal)
                });
            } catch (e) {
                console.error('Firebase error:', e);
            }
        }

        async function loadSignalsFromFirebase() {
            try {
                const response = await fetch(`${FIREBASE_URL}/signals.json`);
                const data = await response.json();
                if (data) {
                    allSignals = Object.values(data).sort((a, b) => b.timestamp - a.timestamp);
                    displaySignals();
                }
            } catch (e) {
                console.error('Firebase load error:', e);
            }
        }

        function displaySignals() {
            const container = document.getElementById('signalsList');
            
            let filtered = allSignals;
            if (signalFilter !== 'all') {
                filtered = allSignals.filter(s => s.bias === signalFilter);
            }
            
            if (!filtered.length) {
                container.innerHTML = `
                    <div class="no-signals">
                        <div class="no-signals-icon">üìä</div>
                        <div>No ${signalFilter === 'all' ? '' : signalFilter} signals</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = filtered.map(s => `
                <div class="signal-card ${s.bias}">
                    <div class="signal-header">
                        <div class="signal-name">${s.name}</div>
                        <div class="signal-badge ${s.bias}">${s.bias.toUpperCase()}</div>
                    </div>
                    <div class="signal-details">
                        <div class="signal-detail">
                            <span class="detail-label">Entry:</span>
                            <span class="detail-value">${s.entry}</span>
                        </div>
                        <div class="signal-detail">
                            <span class="detail-label">TP1:</span>
                            <span class="detail-value green">${s.tp1}</span>
                        </div>
                        <div class="signal-detail">
                            <span class="detail-label">TP2:</span>
                            <span class="detail-value green">${s.tp2}</span>
                        </div>
                        <div class="signal-detail">
                            <span class="detail-label">TP3:</span>
                            <span class="detail-value green">${s.tp3}</span>
                        </div>
                        <div class="signal-detail">
                            <span class="detail-label">SL:</span>
                            <span class="detail-value red">${s.sl}</span>
                        </div>
                        <div class="signal-detail">
                            <span class="detail-label">TF:</span>
                            <span class="detail-value">${getTimeframeLabel(s.timeframe)}</span>
                        </div>
                    </div>
                    <div class="confidence-bar">
                        <div class="confidence-fill ${s.confidence >= 85 ? 'high' : ''}" style="width: ${s.confidence}%"></div>
                    </div>
                    <div class="signal-time">${new Date(s.timestamp).toLocaleString()}</div>
                </div>
            `).join('');
        }

        function filterSignals(type) {
            signalFilter = type;
            document.querySelectorAll('.signal-filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if ((type === 'all' && btn.textContent === 'All') ||
                    (type === 'bullish' && btn.textContent === 'Bullish') ||
                    (type === 'bearish' && btn.textContent === 'Bearish')) {
                    btn.classList.add('active');
                }
            });
            displaySignals();
        }

        async function clearAllSignals() {
            if (confirm('Clear all signals?')) {
                try {
                    await fetch(`${FIREBASE_URL}/signals.json`, { method: 'DELETE' });
                    allSignals = [];
                    displaySignals();
                } catch (e) {
                    console.error('Firebase clear error:', e);
                }
            }
        }

        function getTimeframeLabel(tf) {
            const labels = { 60: '1M', 300: '5M', 900: '15M', 1800: '30M', 3600: '1H' };
            return labels[tf] || `${tf}s`;
        }

        function toggleSetting(el) {
            el.classList.toggle('active');
        }

        function playSound() {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.value = 800;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.3);
        }

        // Initialize
        window.addEventListener('load', () => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
            
            loadSignalsFromFirebase();
            
            window.addEventListener('resize', () => {
                Object.values(charts).forEach(c => {
                    c.resizeCanvas();
                    c.draw();
                });
            });
            
            setTimeout(() => startAllCharts(), 500);
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv Pattern Analyzer - Auto Live with WhatsApp Alerts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1400px;
            width: 100%;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        .info-bar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
            border-radius: 10px;
            color: white;
            flex-wrap: wrap;
        }
        .info-item {
            text-align: center;
            padding: 5px 15px;
        }
        .info-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .info-value {
            font-size: 1.3em;
            font-weight: bold;
            margin-top: 5px;
        }
        .chart-wrapper {
            position: relative;
            margin-bottom: 20px;
        }
        .chart-container {
            position: relative;
            height: 500px;
            background: #1a1a2e;
            border-radius: 10px;
            overflow: hidden;
            cursor: grab;
        }
        .chart-container:active {
            cursor: grabbing;
        }
        #chartCanvas {
            width: 100%;
            height: 100%;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .zoom-btn:hover {
            background: white;
            transform: scale(1.1);
        }
        .zoom-btn:active {
            transform: scale(0.95);
        }
        .zoom-info {
            width: 40px;
            height: 30px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }
        button, select {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
            color: white;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover, select:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        .status.loading {
            background: #fff3cd;
            color: #856404;
        }
        .green { color: #10b981; }
        .red { color: #ef4444; }
        .api-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            color: #1565c0;
            font-size: 14px;
        }
        .api-info a {
            color: #0d47a1;
            font-weight: bold;
            text-decoration: none;
        }
        .api-info a:hover {
            text-decoration: underline;
        }

        /* Pattern Detection Styles */
        .pattern-section {
            margin-top: 30px;
            border-top: 3px solid #FF6B35;
            padding-top: 20px;
        }
        .pattern-header {
            text-align: center;
            font-size: 1.8em;
            color: #333;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .threejs-container {
            height: 200px;
            background: #1a1a2e;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .patterns-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .pattern-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            animation: slideIn 0.5s ease-out;
        }
        .pattern-card.bullish {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        .pattern-card.bearish {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        .pattern-card.neutral {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .pattern-name {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .pattern-timeframe {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
        }
        .pattern-details {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .pattern-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }
        .pattern-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .pattern-value {
            font-weight: bold;
            font-size: 1.1em;
        }
        .confidence-bar {
            margin-top: 10px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }
        .confidence-fill {
            height: 100%;
            background: white;
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        .no-patterns {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1em;
        }
        .alert-badge {
            background: #fbbf24;
            color: #1a1a2e;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
        .auto-live-indicator {
            padding: 12px 24px;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 8px;
            color: #10b981;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .trendline-toggle {
            padding: 12px 24px;
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .trendline-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        .trendline-toggle.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        .trendline-info {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
            max-width: 200px;
        }
        .trendline-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        .trendline-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        .notification-info {
            text-align: center;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(16, 185, 129, 0.1);
            border-radius: 8px;
            border: 2px solid rgba(16, 185, 129, 0.3);
        }
        .notification-info strong {
            color: #10b981;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Deriv Pattern Analyzer</h1>
        <div class="subtitle">Auto-Live Chart with AI Pattern Detection & WhatsApp Alerts</div>
        
        <div class="api-info">
            <strong>üéØ No API Key Required!</strong> Auto-connecting to Deriv's WebSocket API
        </div>

        <div class="controls">
            <select id="symbol">
                <option value="R_10">Volatility 10 Index</option>
                <option value="R_25" selected>Volatility 25 Index</option>
                <option value="R_50">Volatility 50 Index</option>
                <option value="R_75">Volatility 75 Index</option>
                <option value="R_100">Volatility 100 Index</option>
                <option value="1HZ10V">Volatility 10 (1s) Index</option>
                <option value="1HZ25V">Volatility 25 (1s) Index</option>
                <option value="1HZ50V">Volatility 50 (1s) Index</option>
                <option value="1HZ75V">Volatility 75 (1s) Index</option>
                <option value="1HZ100V">Volatility 100 (1s) Index</option>
            </select>
            <select id="timeframe">
                <option value="60">1 Minute</option>
                <option value="120">2 Minutes</option>
                <option value="300" selected>5 Minutes</option>
                <option value="900">15 Minutes</option>
                <option value="1800">30 Minutes</option>
                <option value="3600">1 Hour</option>
            </select>
            <button onclick="stopChart()" id="stopBtn" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">‚è∏Ô∏è Stop Chart</button>
            <button onclick="toggleTrendlines()" id="trendlineToggle" class="trendline-toggle active">üìà Trendlines: ON</button>
            <div class="auto-live-indicator">
                <span style="font-size: 1.2em;">üü¢</span>
                <span>Auto-Live Mode</span>
            </div>
        </div>
        
        <div class="info-bar">
            <div class="info-item">
                <div class="info-label">Current Price</div>
                <div class="info-value" id="currentPrice">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">Change</div>
                <div class="info-value" id="priceChange">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">High</div>
                <div class="info-value" id="highPrice">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">Low</div>
                <div class="info-value" id="lowPrice">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">Last Update</div>
                <div class="info-value" id="lastUpdate">--</div>
            </div>
        </div>

        <div class="chart-wrapper">
            <div class="chart-container" id="chartContainer">
                <canvas id="chartCanvas"></canvas>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                    <div class="zoom-info" id="zoomLevel">100</div>
                    <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                </div>
                <div class="trendline-info" id="trendlineInfo" style="display: none;">
                    <div style="font-weight: bold; margin-bottom: 5px;">üìä Active Trendlines</div>
                    <div id="trendlineList"></div>
                </div>
            </div>
        </div>

        <div class="status loading" id="status">üöÄ Auto-starting live chart...</div>

        <!-- Pattern Detection Section -->
        <div class="pattern-section" id="patternSection">
            <div class="pattern-header">üéØ Live Pattern Detection & Trading Signals</div>
            <div class="notification-info">
                <strong>üì± WhatsApp Alerts Enabled!</strong><br>
                High confidence patterns (85%+) will trigger notifications to: <strong>+26659878360</strong>
            </div>
            <div class="threejs-container" id="threejsContainer"></div>
            <div class="patterns-container" id="patternsContainer">
                <div class="no-patterns">üîç Scanning latest 50 candlesticks for patterns...</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        
        const WHATSAPP_NUMBER = '+26659878360';
        
        // Replace this with your backend webhook URL for WhatsApp integration
        // You can use services like:
        // - Twilio: https://www.twilio.com/docs/whatsapp
        // - WhatsApp Business API
        // - MessageBird: https://www.messagebird.com/
        // - Your own Node.js server with whatsapp-web.js
        const WEBHOOK_URL = 'https://your-backend-server.com/api/send-whatsapp';
        
        // ============================================
        // PATTERN ANALYZER CLASS (Embedded)
        // ============================================
        
        class PatternAnalyzer {
            constructor() {
                this.patterns = [];
                this.activeTimeframes = [60, 120, 300, 900, 1800, 3600];
                this.candleData = {
                    60: [], 120: [], 300: [], 900: [], 1800: [], 3600: []
                };
                this.detectedPatterns = [];
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.patternMeshes = [];
            }

            initThreeJS(container) {
                const width = container.clientWidth;
                const height = 200;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.z = 50;
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                container.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 1, 1);
                this.scene.add(directionalLight);

                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.patternMeshes.forEach(mesh => {
                    mesh.rotation.y += 0.005;
                });
                this.renderer.render(this.scene, this.camera);
            }

            updateCandleData(mainCandles, timeframe) {
                if (!this.activeTimeframes.includes(timeframe)) return;
                this.candleData[timeframe] = mainCandles.slice(-100);
                this.detectPatterns(timeframe);
            }

            detectPatterns(timeframe) {
                const candles = this.candleData[timeframe];
                if (candles.length < 20) return;
                const recentCandles = candles.slice(-50);
                
                this.detectTriangle(recentCandles, timeframe, 'symmetrical');
                this.detectTriangle(recentCandles, timeframe, 'ascending');
                this.detectTriangle(recentCandles, timeframe, 'descending');
                this.detectHeadAndShoulders(recentCandles, timeframe, false);
                this.detectHeadAndShoulders(recentCandles, timeframe, true);
                this.detectDoubleTopBottom(recentCandles, timeframe, 'top');
                this.detectDoubleTopBottom(recentCandles, timeframe, 'bottom');
                this.detectWedge(recentCandles, timeframe, 'rising');
                this.detectWedge(recentCandles, timeframe, 'falling');
                this.detectFlag(recentCandles, timeframe, 'bull');
                this.detectFlag(recentCandles, timeframe, 'bear');
            }

            detectTriangle(candles, timeframe, type) {
                if (candles.length < 20) return null;
                const highs = candles.map(c => c.h);
                const lows = candles.map(c => c.l);
                const peaks = this.findPeaks(highs);
                const troughs = this.findTroughs(lows);
                if (peaks.length < 2 || troughs.length < 2) return null;

                const recentPeaks = peaks.slice(-3);
                const recentTroughs = troughs.slice(-3);
                const upperSlope = this.calculateSlope(recentPeaks.map((p, i) => [i, highs[p]]));
                const lowerSlope = this.calculateSlope(recentTroughs.map((t, i) => [i, lows[t]]));

                let isPattern = false;
                let bias = 'neutral';

                if (type === 'symmetrical' && upperSlope < -0.001 && lowerSlope > 0.001) {
                    isPattern = true;
                    bias = this.determineTrendBias(candles);
                } else if (type === 'ascending' && Math.abs(upperSlope) < 0.002 && lowerSlope > 0.001) {
                    isPattern = true;
                    bias = 'bullish';
                } else if (type === 'descending' && upperSlope < -0.001 && Math.abs(lowerSlope) < 0.002) {
                    isPattern = true;
                    bias = 'bearish';
                }

                if (isPattern) {
                    const currentPrice = candles[candles.length - 1].c;
                    const pattern = this.createPatternSignal(
                        `${type.charAt(0).toUpperCase() + type.slice(1)} Triangle`,
                        bias, currentPrice, timeframe, candles
                    );
                    this.addPattern(pattern);

                    // Draw trendlines for triangle
                    const upperLine = recentPeaks.map(idx => ({
                        x: candles[idx].x,
                        y: highs[idx]
                    }));
                    const lowerLine = recentTroughs.map(idx => ({
                        x: candles[idx].x,
                        y: lows[idx]
                    }));

                    if (window.onTrendlineDetected) {
                        window.onTrendlineDetected({
                            points: upperLine,
                            label: 'Resistance',
                            color: '#ef4444',
                            patternType: `triangle-upper-${type}`
                        });
                        window.onTrendlineDetected({
                            points: lowerLine,
                            label: 'Support',
                            color: '#10b981',
                            patternType: `triangle-lower-${type}`
                        });
                    }
                }
            }

            detectHeadAndShoulders(candles, timeframe, inverse = false) {
                if (candles.length < 25) return null;
                const prices = inverse ? candles.map(c => c.l) : candles.map(c => c.h);
                const extremes = inverse ? this.findTroughs(prices) : this.findPeaks(prices);
                if (extremes.length < 5) return null;

                const recent = extremes.slice(-5);
                if (recent.length === 5) {
                    const [ls, lh, head, rh, rs] = recent.map(i => prices[i]);
                    const leftShoulderValid = Math.abs(ls - lh) < (head - ls) * 0.3;
                    const rightShoulderValid = Math.abs(rs - rh) < (head - rs) * 0.3;
                    const headHigher = inverse ? (head < ls && head < rs) : (head > ls && head > rs);
                    const shouldersLevel = Math.abs(ls - rs) / ls < 0.02;

                    if (leftShoulderValid && rightShoulderValid && headHigher && shouldersLevel) {
                        const currentPrice = candles[candles.length - 1].c;
                        const pattern = this.createPatternSignal(
                            inverse ? 'Inverse Head and Shoulders' : 'Head and Shoulders',
                            inverse ? 'bullish' : 'bearish',
                            currentPrice, timeframe, candles
                        );
                        this.addPattern(pattern);

                        // Draw neckline
                        const necklinePrice = (prices[recent[1]] + prices[recent[3]]) / 2;
                        const necklinePoints = [
                            { x: candles[recent[1]].x, y: necklinePrice },
                            { x: candles[recent[3]].x, y: necklinePrice },
                            { x: candles[candles.length - 1].x, y: necklinePrice }
                        ];

                        if (window.onTrendlineDetected) {
                            window.onTrendlineDetected({
                                points: necklinePoints,
                                label: 'Neckline',
                                color: '#fbbf24',
                                patternType: inverse ? 'inv-h&s-neckline' : 'h&s-neckline'
                            });

                            // Draw pattern outline
                            const patternOutline = recent.map(idx => ({
                                x: candles[idx].x,
                                y: prices[idx]
                            }));
                            window.onTrendlineDetected({
                                points: patternOutline,
                                label: inverse ? 'Inv H&S' : 'H&S',
                                color: inverse ? '#10b981' : '#ef4444',
                                patternType: inverse ? 'inv-h&s-outline' : 'h&s-outline'
                            });
                        }
                    }
                }
            }

            detectDoubleTopBottom(candles, timeframe, type) {
                if (candles.length < 20) return null;
                const prices = type === 'top' ? candles.map(c => c.h) : candles.map(c => c.l);
                const extremes = type === 'top' ? this.findPeaks(prices) : this.findTroughs(prices);
                if (extremes.length < 2) return null;

                const recent = extremes.slice(-2);
                const [first, second] = recent.map(i => prices[i]);
                const similarity = Math.abs(first - second) / first;
                
                if (similarity < 0.015) {
                    const currentPrice = candles[candles.length - 1].c;
                    const pattern = this.createPatternSignal(
                        `Double ${type.charAt(0).toUpperCase() + type.slice(1)}`,
                        type === 'top' ? 'bearish' : 'bullish',
                        currentPrice, timeframe, candles
                    );
                    this.addPattern(pattern);

                    // Draw double top/bottom levels
                    const level = (first + second) / 2;
                    const levelPoints = [
                        { x: candles[recent[0]].x, y: level },
                        { x: candles[recent[1]].x, y: level }
                    ];

                    if (window.onTrendlineDetected) {
                        window.onTrendlineDetected({
                            points: levelPoints,
                            label: type === 'top' ? 'Double Top' : 'Double Bottom',
                            color: type === 'top' ? '#ef4444' : '#10b981',
                            patternType: `double-${type}`
                        });

                        // Draw connecting line between peaks/troughs
                        const connectingLine = recent.map(idx => ({
                            x: candles[idx].x,
                            y: prices[idx]
                        }));
                        window.onTrendlineDetected({
                            points: connectingLine,
                            label: '',
                            color: type === 'top' ? '#ef4444' : '#10b981',
                            patternType: `double-${type}-connect`
                        });
                    }
                }
            }

            detectWedge(candles, timeframe, type) {
                if (candles.length < 20) return null;
                const highs = candles.map(c => c.h);
                const lows = candles.map(c => c.l);
                const peaks = this.findPeaks(highs);
                const troughs = this.findTroughs(lows);
                if (peaks.length < 2 || troughs.length < 2) return null;

                const recentPeaks = peaks.slice(-3);
                const recentTroughs = troughs.slice(-3);
                const upperSlope = this.calculateSlope(recentPeaks.map((p, i) => [i, highs[p]]));
                const lowerSlope = this.calculateSlope(recentTroughs.map((t, i) => [i, lows[t]]));

                let isPattern = false;
                let bias = 'neutral';

                if (type === 'rising' && upperSlope > 0.001 && lowerSlope > 0.001 && lowerSlope > upperSlope) {
                    isPattern = true;
                    bias = 'bearish';
                } else if (type === 'falling' && upperSlope < -0.001 && lowerSlope < -0.001 && upperSlope < lowerSlope) {
                    isPattern = true;
                    bias = 'bullish';
                }

                if (isPattern) {
                    const currentPrice = candles[candles.length - 1].c;
                    const pattern = this.createPatternSignal(
                        `${type.charAt(0).toUpperCase() + type.slice(1)} Wedge`,
                        bias, currentPrice, timeframe, candles
                    );
                    this.addPattern(pattern);

                    // Draw wedge lines
                    const upperLine = recentPeaks.map(idx => ({
                        x: candles[idx].x,
                        y: highs[idx]
                    }));
                    const lowerLine = recentTroughs.map(idx => ({
                        x: candles[idx].x,
                        y: lows[idx]
                    }));

                    if (window.onTrendlineDetected) {
                        window.onTrendlineDetected({
                            points: upperLine,
                            label: 'Upper',
                            color: '#f97316',
                            patternType: `wedge-upper-${type}`
                        });
                        window.onTrendlineDetected({
                            points: lowerLine,
                            label: 'Lower',
                            color: '#f97316',
                            patternType: `wedge-lower-${type}`
                        });
                    }
                }
            }

            detectFlag(candles, timeframe, type) {
                if (candles.length < 15) return null;
                const recent = candles.slice(-15);
                const pole = recent.slice(0, 5);
                const flag = recent.slice(5);

                const poleMove = type === 'bull' ? 
                    (pole[4].c - pole[0].o) / pole[0].o :
                    (pole[0].o - pole[4].c) / pole[0].o;

                if (poleMove < 0.02) return null;

                const flagRange = Math.max(...flag.map(c => c.h)) - Math.min(...flag.map(c => c.l));
                const flagAvg = flag.reduce((sum, c) => sum + c.c, 0) / flag.length;
                const consolidation = flagRange / flagAvg;

                if (consolidation < 0.015) {
                    const currentPrice = candles[candles.length - 1].c;
                    const pattern = this.createPatternSignal(
                        `${type === 'bull' ? 'Bull' : 'Bear'} Flag`,
                        type === 'bull' ? 'bullish' : 'bearish',
                        currentPrice, timeframe, candles
                    );
                    this.addPattern(pattern);

                    // Draw pole line
                    const polePoints = [
                        { x: pole[0].x, y: pole[0].o },
                        { x: pole[4].x, y: pole[4].c }
                    ];

                    // Draw flag consolidation box
                    const flagHigh = Math.max(...flag.map(c => c.h));
                    const flagLow = Math.min(...flag.map(c => c.l));
                    const flagBox = [
                        { x: flag[0].x, y: flagHigh },
                        { x: flag[flag.length - 1].x, y: flagHigh },
                        { x: flag[flag.length - 1].x, y: flagLow },
                        { x: flag[0].x, y: flagLow },
                        { x: flag[0].x, y: flagHigh }
                    ];

                    if (window.onTrendlineDetected) {
                        window.onTrendlineDetected({
                            points: polePoints,
                            label: 'Pole',
                            color: type === 'bull' ? '#10b981' : '#ef4444',
                            patternType: `flag-pole-${type}`
                        });
                        window.onTrendlineDetected({
                            points: flagBox,
                            label: 'Flag',
                            color: type === 'bull' ? '#10b981' : '#ef4444',
                            patternType: `flag-box-${type}`
                        });
                    }
                }
            }

            findPeaks(prices) {
                const peaks = [];
                for (let i = 2; i < prices.length - 2; i++) {
                    if (prices[i] > prices[i - 1] && prices[i] > prices[i - 2] &&
                        prices[i] > prices[i + 1] && prices[i] > prices[i + 2]) {
                        peaks.push(i);
                    }
                }
                return peaks;
            }

            findTroughs(prices) {
                const troughs = [];
                for (let i = 2; i < prices.length - 2; i++) {
                    if (prices[i] < prices[i - 1] && prices[i] < prices[i - 2] &&
                        prices[i] < prices[i + 1] && prices[i] < prices[i + 2]) {
                        troughs.push(i);
                    }
                }
                return troughs;
            }

            calculateSlope(points) {
                if (points.length < 2) return 0;
                const n = points.length;
                const sumX = points.reduce((sum, p) => sum + p[0], 0);
                const sumY = points.reduce((sum, p) => sum + p[1], 0);
                const sumXY = points.reduce((sum, p) => sum + p[0] * p[1], 0);
                const sumX2 = points.reduce((sum, p) => sum + p[0] * p[0], 0);
                return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            }

            determineTrendBias(candles) {
                const recent = candles.slice(-20);
                const startPrice = recent[0].o;
                const endPrice = recent[recent.length - 1].c;
                return endPrice > startPrice ? 'bullish' : 'bearish';
            }

            createPatternSignal(patternName, bias, currentPrice, timeframe, candles) {
                const atr = this.calculateATR(candles.slice(-14));
                let entry, tp1, tp2, tp3, sl;

                if (bias === 'bullish') {
                    entry = currentPrice * 1.001;
                    tp1 = entry + (atr * 1.5);
                    tp2 = entry + (atr * 2.5);
                    tp3 = entry + (atr * 3.5);
                    sl = entry - (atr * 1);
                } else if (bias === 'bearish') {
                    entry = currentPrice * 0.999;
                    tp1 = entry - (atr * 1.5);
                    tp2 = entry - (atr * 2.5);
                    tp3 = entry - (atr * 3.5);
                    sl = entry + (atr * 1);
                } else {
                    entry = currentPrice;
                    tp1 = currentPrice + (atr * 1.5);
                    tp2 = currentPrice + (atr * 2.5);
                    tp3 = currentPrice + (atr * 3.5);
                    sl = currentPrice - (atr * 1.5);
                }

                return {
                    id: Date.now() + Math.random(),
                    name: patternName,
                    bias: bias,
                    timeframe: timeframe,
                    entry: entry.toFixed(2),
                    tp1: tp1.toFixed(2),
                    tp2: tp2.toFixed(2),
                    tp3: tp3.toFixed(2),
                    sl: sl.toFixed(2),
                    currentPrice: currentPrice.toFixed(2),
                    confidence: this.calculateConfidence(candles, bias),
                    timestamp: Date.now()
                };
            }

            calculateATR(candles, period = 14) {
                if (candles.length < period) return 0;
                const trs = [];
                for (let i = 1; i < candles.length; i++) {
                    const tr = Math.max(
                        candles[i].h - candles[i].l,
                        Math.abs(candles[i].h - candles[i - 1].c),
                        Math.abs(candles[i].l - candles[i - 1].c)
                    );
                    trs.push(tr);
                }
                return trs.slice(-period).reduce((sum, tr) => sum + tr, 0) / period;
            }

            calculateConfidence(candles, bias) {
                const recent = candles.slice(-10);
                let confirming = 0;
                let momentum = 0;

                for (let i = 1; i < recent.length; i++) {
                    if (bias === 'bullish' && recent[i].c > recent[i - 1].c) confirming++;
                    if (bias === 'bearish' && recent[i].c < recent[i - 1].c) confirming++;
                }

                const startPrice = recent[0].c;
                const endPrice = recent[recent.length - 1].c;
                momentum = Math.abs((endPrice - startPrice) / startPrice) * 100;

                let confidence = (confirming / (recent.length - 1)) * 100;
                if (momentum > 1) confidence += 5;
                if (momentum > 2) confidence += 5;
                
                const atr = this.calculateATR(candles.slice(-14));
                const volatilityFactor = (atr / endPrice) * 100;
                if (volatilityFactor > 0.5 && volatilityFactor < 2) {
                    confidence += 10;
                }

                return Math.min(100, Math.round(confidence));
            }

            addPattern(pattern) {
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                const existing = this.detectedPatterns.find(p => 
                    p.name === pattern.name && 
                    p.timeframe === pattern.timeframe && 
                    p.timestamp > fiveMinutesAgo
                );

                if (!existing) {
                    this.detectedPatterns.unshift(pattern);
                    this.detectedPatterns = this.detectedPatterns.slice(0, 10);
                    this.visualizePattern(pattern);
                    this.notifyPattern(pattern);
                    
                    if (pattern.confidence >= 85) {
                        this.sendHighConfidenceAlert(pattern);
                    }
                }
            }

            sendHighConfidenceAlert(pattern) {
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('üéØ High Confidence Pattern!', {
                        body: `${pattern.name} - ${pattern.bias.toUpperCase()} - ${pattern.confidence}%`,
                        icon: 'üìä',
                        tag: pattern.id
                    });
                }

                if (window.sendWhatsAppNotification) {
                    window.sendWhatsAppNotification(pattern);
                }

                console.log('üö® HIGH CONFIDENCE ALERT:', pattern);
            }

            visualizePattern(pattern) {
                const geometry = new THREE.IcosahedronGeometry(5, 0);
                let color;
                switch (pattern.bias) {
                    case 'bullish': color = 0x10b981; break;
                    case 'bearish': color = 0xef4444; break;
                    default: color = 0xfbbf24;
                }

                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );

                this.scene.add(mesh);
                this.patternMeshes.push(mesh);

                setTimeout(() => {
                    this.scene.remove(mesh);
                    this.patternMeshes = this.patternMeshes.filter(m => m !== mesh);
                }, 10000);
            }

            notifyPattern(pattern) {
                if (window.onPatternDetected) {
                    window.onPatternDetected(pattern);
                }
            }

            clearOldPatterns() {
                const oneHourAgo = Date.now() - (60 * 60 * 1000);
                this.detectedPatterns = this.detectedPatterns.filter(p => p.timestamp > oneHourAgo);
            }
        }

        // ============================================
        // WHATSAPP NOTIFICATION FUNCTION
        // ============================================
        
        window.sendWhatsAppNotification = async function(pattern) {
            const message = `üö® *HIGH CONFIDENCE TRADING SIGNAL* üö®

üìä Pattern: *${pattern.name}*
üìà Bias: *${pattern.bias.toUpperCase()}*
‚ö° Confidence: *${pattern.confidence}%*
üí∞ Current Price: ${pattern.currentPrice}

üéØ *Trading Setup:*
üìç Entry: ${pattern.entry}
üéØ TP1: ${pattern.tp1} (Conservative)
üéØ TP2: ${pattern.tp2} (Moderate)
üéØ TP3: ${pattern.tp3} (Aggressive)
üõë SL: ${pattern.sl}

‚è∞ Time: ${new Date().toLocaleString()}
üìä Timeframe: ${getTimeframeLabel(pattern.timeframe)}

Trade wisely! üí™`;

            console.log('üì± WhatsApp Message Ready:', message);

            // Method 1: Using backend webhook (recommended)
            try {
                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        phone: WHATSAPP_NUMBER,
                        message: message,
                        pattern: pattern
                    })
                });
                
                if (response.ok) {
                    console.log('‚úÖ WhatsApp notification sent successfully');
                    showNotificationToast('‚úÖ WhatsApp alert sent!');
                } else {
                    console.error('‚ùå Failed to send WhatsApp notification');
                    fallbackWhatsAppMethod(message);
                }
            } catch (error) {
                console.error('‚ùå WhatsApp notification error:', error);
                fallbackWhatsAppMethod(message);
            }
        };

        function fallbackWhatsAppMethod(message) {
            // Fallback: Generate WhatsApp Web link
            const encodedMessage = encodeURIComponent(message);
            const phoneNumber = WHATSAPP_NUMBER.replace(/[^0-9]/g, '');
            const whatsappUrl = `https://wa.me/${phoneNumber}?text=${encodedMessage}`;
            
            console.log('üì± WhatsApp URL generated:', whatsappUrl);
            showNotificationToast('üì± Click to send WhatsApp alert', whatsappUrl);
        }

        function showNotificationToast(message, url = null) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: bold;
                cursor: ${url ? 'pointer' : 'default'};
                animation: slideInRight 0.3s ease-out;
            `;
            toast.textContent = message;
            
            if (url) {
                toast.onclick = () => window.open(url, '_blank');
            }
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 5000);
        }

        // ============================================
        // CHART VARIABLES
        // ============================================
        
        let canvas, ctx;
        let candlestickData = [];
        let ws;
        let symbol = 'R_25';
        let timeframe = 300;
        let currentCandle = null;
        let chartPadding = { top: 40, right: 60, bottom: 40, left: 60 };
        let isConnected = false;
        
        let candlesPerScreen = 100;
        let scrollOffset = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartOffset = 0;
        let autoScroll = true;

        let patternAnalyzer = null;
        let patternDetectionEnabled = true;

        // ============================================
        // CANVAS INITIALIZATION
        // ============================================
        
        function initCanvas() {
            canvas = document.getElementById('chartCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            const container = document.getElementById('chartContainer');
            
            container.addEventListener('mousedown', startDrag);
            container.addEventListener('mousemove', drag);
            container.addEventListener('mouseup', endDrag);
            container.addEventListener('mouseleave', endDrag);
            
            container.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                startDrag({ clientX: touch.clientX });
                e.preventDefault();
            });
            container.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                drag({ clientX: touch.clientX });
                e.preventDefault();
            });
            container.addEventListener('touchend', endDrag);
            
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }, { passive: false });
        }

        function startDrag(e) {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartOffset = scrollOffset;
            autoScroll = false;
        }

        function drag(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - dragStartX;
            const pixelsPerCandle = (canvas.width - chartPadding.left - chartPadding.right) / candlesPerScreen;
            const candlesDelta = Math.round(deltaX / pixelsPerCandle);
            
            scrollOffset = Math.max(0, Math.min(
                candlestickData.length - candlesPerScreen,
                dragStartOffset - candlesDelta
            ));
            
            drawChart();
        }

        function endDrag() {
            isDragging = false;
            if (scrollOffset >= candlestickData.length - candlesPerScreen - 5) {
                autoScroll = true;
            }
        }

        function zoomIn() {
            candlesPerScreen = Math.max(20, candlesPerScreen - 10);
            updateZoomDisplay();
            adjustScrollAfterZoom();
            drawChart();
        }

        function zoomOut() {
            candlesPerScreen = Math.min(500, candlesPerScreen + 10);
            updateZoomDisplay();
            adjustScrollAfterZoom();
            drawChart();
        }

        function updateZoomDisplay() {
            const zoomPercent = Math.round((100 / candlesPerScreen) * 100);
            document.getElementById('zoomLevel').textContent = zoomPercent;
        }

        function adjustScrollAfterZoom() {
            if (autoScroll) {
                scrollOffset = Math.max(0, candlestickData.length - candlesPerScreen);
            } else {
                scrollOffset = Math.max(0, Math.min(
                    candlestickData.length - candlesPerScreen,
                    scrollOffset
                ));
            }
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (candlestickData.length > 0) {
                drawChart();
            }
        }

        // ============================================
        // CHART DRAWING
        // ============================================
        
        function drawChart() {
            if (!ctx || candlestickData.length === 0) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const chartWidth = canvas.width - chartPadding.left - chartPadding.right;
            const chartHeight = canvas.height - chartPadding.top - chartPadding.bottom;

            if (autoScroll) {
                scrollOffset = Math.max(0, candlestickData.length - candlesPerScreen);
            }

            const endIndex = Math.min(candlestickData.length, scrollOffset + candlesPerScreen);
            const startIndex = Math.max(0, endIndex - candlesPerScreen);
            const visibleCandles = candlestickData.slice(startIndex, endIndex);

            if (visibleCandles.length === 0) return;

            const allPrices = visibleCandles.flatMap(c => [c.h, c.l]);
            const maxPrice = Math.max(...allPrices);
            const minPrice = Math.min(...allPrices);
            const priceRange = maxPrice - minPrice;
            const padding = priceRange * 0.1;

            const candleWidth = Math.max(2, Math.min(20, (chartWidth / visibleCandles.length) - 2));
            const spacing = chartWidth / visibleCandles.length;

            // Grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = chartPadding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(canvas.width - chartPadding.right, y);
                ctx.stroke();

                const price = maxPrice + padding - (priceRange + padding * 2) * (i / 5);
                ctx.fillStyle = '#888';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(price.toFixed(2), chartPadding.left - 10, y + 4);
            }

            // Draw candles
            visibleCandles.forEach((candle, index) => {
                const x = chartPadding.left + spacing * index + spacing / 2;

                const yHigh = chartPadding.top + ((maxPrice + padding - candle.h) / (priceRange + padding * 2)) * chartHeight;
                const yLow = chartPadding.top + ((maxPrice + padding - candle.l) / (priceRange + padding * 2)) * chartHeight;
                const yOpen = chartPadding.top + ((maxPrice + padding - candle.o) / (priceRange + padding * 2)) * chartHeight;
                const yClose = chartPadding.top + ((maxPrice + padding - candle.c) / (priceRange + padding * 2)) * chartHeight;

                const isUp = candle.c >= candle.o;
                const color = isUp ? '#10b981' : '#ef4444';

                ctx.strokeStyle = color;
                ctx.lineWidth = Math.max(1, candleWidth / 4);
                ctx.beginPath();
                ctx.moveTo(x, yHigh);
                ctx.lineTo(x, yLow);
                ctx.stroke();

                ctx.fillStyle = color;
                const bodyHeight = Math.max(Math.abs(yClose - yOpen), 1);
                ctx.fillRect(x - candleWidth / 2, Math.min(yOpen, yClose), candleWidth, bodyHeight);
            });

            // Time labels
            const maxLabels = Math.min(10, Math.floor(visibleCandles.length / 5));
            const labelStep = Math.max(1, Math.floor(visibleCandles.length / maxLabels));
            ctx.fillStyle = '#888';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            visibleCandles.forEach((candle, index) => {
                if (index % labelStep === 0 || index === visibleCandles.length - 1) {
                    const x = chartPadding.left + spacing * index + spacing / 2;
                    const date = new Date(candle.x);
                    const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    ctx.fillText(timeStr, x, canvas.height - chartPadding.bottom + 20);
                }
            });

            // Title
            const symbolName = document.getElementById('symbol').options[document.getElementById('symbol').selectedIndex].text;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(symbolName, canvas.width / 2, 25);

            // Scroll indicator
            if (!autoScroll && scrollOffset < candlestickData.length - candlesPerScreen - 2) {
                ctx.fillStyle = 'rgba(255, 107, 53, 0.7)';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('‚óÑ Scroll to see live updates', canvas.width - chartPadding.right - 10, chartPadding.top + 20);
            }

            // Draw trendlines
            drawTrendlines(visibleCandles, chartPadding, chartWidth, chartHeight, maxPrice, minPrice, priceRange, padding, spacing);
        }

        // ============================================
        // TRENDLINE DRAWING
        // ============================================
        
        function drawTrendlines(visibleCandles, chartPadding, chartWidth, chartHeight, maxPrice, minPrice, priceRange, padding, spacing) {
            if (detectedTrendlines.length === 0 || !showTrendlines) return;

            const now = Date.now();
            
            detectedTrendlines.forEach((trendline, index) => {
                // Remove expired trendlines (older than 1 hour)
                if (now - trendline.timestamp > 60 * 60 * 1000) {
                    detectedTrendlines.splice(index, 1);
                    return;
                }

                // Only draw trendlines that are visible in current view
                const firstVisibleTime = visibleCandles[0].x;
                const lastVisibleTime = visibleCandles[visibleCandles.length - 1].x;

                // Check if trendline overlaps with visible area
                const trendlineStart = trendline.points[0].x;
                const trendlineEnd = trendline.points[trendline.points.length - 1].x;

                if (trendlineEnd < firstVisibleTime || trendlineStart > lastVisibleTime) {
                    return; // Trendline not in view
                }

                // Draw the trendline
                ctx.save();
                ctx.strokeStyle = trendline.color;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = 0.85;

                ctx.beginPath();
                let firstPoint = true;

                trendline.points.forEach((point, i) => {
                    // Find the index in visible candles
                    const candleIndex = visibleCandles.findIndex(c => Math.abs(c.x - point.x) < 30000);
                    
                    if (candleIndex !== -1) {
                        const x = chartPadding.left + spacing * candleIndex + spacing / 2;
                        const y = chartPadding.top + ((maxPrice + padding - point.y) / (priceRange + padding * 2)) * chartHeight;

                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });

                ctx.stroke();

                // Draw label at the end of the line
                if (trendline.points.length > 0 && trendline.label) {
                    const lastPoint = trendline.points[trendline.points.length - 1];
                    const lastCandleIndex = visibleCandles.findIndex(c => Math.abs(c.x - lastPoint.x) < 30000);
                    
                    if (lastCandleIndex !== -1) {
                        const labelX = chartPadding.left + spacing * lastCandleIndex + spacing / 2 + 10;
                        const labelY = chartPadding.top + ((maxPrice + padding - lastPoint.y) / (priceRange + padding * 2)) * chartHeight;

                        // Draw label background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.globalAlpha = 1;
                        const textWidth = ctx.measureText(trendline.label).width;
                        ctx.fillRect(labelX - 2, labelY - 15, textWidth + 8, 18);

                        // Draw label text
                        ctx.fillStyle = trendline.color;
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(trendline.label, labelX + 2, labelY - 3);
                    }
                }

                ctx.restore();
            });

            // Update trendline info panel
            updateTrendlineInfo();
        }

        function updateTrendlineInfo() {
            if (detectedTrendlines.length === 0 || !showTrendlines) {
                document.getElementById('trendlineInfo').style.display = 'none';
                return;
            }

            document.getElementById('trendlineInfo').style.display = 'block';
            const listEl = document.getElementById('trendlineList');
            listEl.innerHTML = '';

            detectedTrendlines.slice(0, 5).forEach(tl => {
                if (tl.label) {
                    const item = document.createElement('div');
                    item.className = 'trendline-item';
                    item.innerHTML = `
                        <div class="trendline-color" style="background: ${tl.color};"></div>
                        <span>${tl.label}</span>
                    `;
                    listEl.appendChild(item);
                }
            });
        }

        function addTrendline(points, label, color, patternType) {
            // Remove old trendlines of the same type
            detectedTrendlines = detectedTrendlines.filter(t => t.patternType !== patternType);

            detectedTrendlines.push({
                points: points,
                label: label,
                color: color,
                patternType: patternType,
                timestamp: Date.now()
            });

            // Keep only last 15 trendlines
            if (detectedTrendlines.length > 15) {
                detectedTrendlines.shift();
            }

            drawChart();
        }

        function toggleTrendlines() {
            showTrendlines = !showTrendlines;
            const btn = document.getElementById('trendlineToggle');
            
            if (showTrendlines) {
                btn.textContent = 'üìà Trendlines: ON';
                btn.classList.add('active');
            } else {
                btn.textContent = 'üìà Trendlines: OFF';
                btn.classList.remove('active');
                document.getElementById('trendlineInfo').style.display = 'none';
            }
            
            drawChart();
        }

        function clearAllTrendlines() {
            detectedTrendlines = [];
            drawChart();
        }

        // Callback for pattern analyzer to add trendlines
        window.onTrendlineDetected = function(trendlineData) {
            addTrendline(
                trendlineData.points,
                trendlineData.label,
                trendlineData.color,
                trendlineData.patternType
            );
        };

        // ============================================
        // WEBSOCKET CONNECTION
        // ============================================
        
        function connectWebSocket() {
            const app_id = 1089;
            ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

            ws.onopen = () => {
                console.log('WebSocket connected');
                updateStatus('connected', 'üü¢ Connected & Live');
                
                ws.send(JSON.stringify({
                    ticks: symbol,
                    subscribe: 1
                }));

                ws.send(JSON.stringify({
                    ticks_history: symbol,
                    count: 1000,
                    end: 'latest',
                    style: 'candles',
                    granularity: timeframe
                }));
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.error) {
                    console.error('API Error:', data.error);
                    updateStatus('disconnected', `üî¥ Error: ${data.error.message}`);
                    return;
                }

                if (data.msg_type === 'candles' && data.candles) {
                    candlestickData = data.candles.map(c => ({
                        x: c.epoch * 1000,
                        o: parseFloat(c.open),
                        h: parseFloat(c.high),
                        l: parseFloat(c.low),
                        c: parseFloat(c.close)
                    }));

                    if (candlestickData.length > 0) {
                        currentCandle = { ...candlestickData[candlestickData.length - 1] };
                    }

                    drawChart();
                    updateInfoBar();
                    
                    if (patternDetectionEnabled && patternAnalyzer) {
                        patternAnalyzer.updateCandleData(candlestickData, timeframe);
                    }
                } else if (data.msg_type === 'tick') {
                    const price = parseFloat(data.tick.quote);
                    const timestamp = data.tick.epoch * 1000;

                    if (!currentCandle) {
                        currentCandle = {
                            x: Math.floor(timestamp / (timeframe * 1000)) * (timeframe * 1000),
                            o: price,
                            h: price,
                            l: price,
                            c: price
                        };
                        candlestickData.push(currentCandle);
                    } else {
                        const candleStart = Math.floor(timestamp / (timeframe * 1000)) * (timeframe * 1000);
                        
                        if (candleStart > currentCandle.x) {
                            currentCandle = {
                                x: candleStart,
                                o: price,
                                h: price,
                                l: price,
                                c: price
                            };
                            candlestickData.push(currentCandle);
                            
                            if (candlestickData.length > 1000) {
                                candlestickData.shift();
                                if (!autoScroll && scrollOffset > 0) {
                                    scrollOffset--;
                                }
                            }
                        } else {
                            currentCandle.c = price;
                            currentCandle.h = Math.max(currentCandle.h, price);
                            currentCandle.l = Math.min(currentCandle.l, price);
                            candlestickData[candlestickData.length - 1] = currentCandle;
                        }
                    }

                    drawChart();
                    updateInfoBar();
                    
                    if (patternDetectionEnabled && patternAnalyzer) {
                        patternAnalyzer.updateCandleData(candlestickData, timeframe);
                    }
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('disconnected', 'üî¥ Connection error');
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                isConnected = false;
                if (candlestickData.length > 0) {
                    updateStatus('disconnected', 'üî¥ Disconnected');
                }
            };
        }

        // ============================================
        // UI UPDATES
        // ============================================
        
        function updateInfoBar() {
            if (candlestickData.length === 0) return;

            const currentCandle = candlestickData[candlestickData.length - 1];
            const firstCandle = candlestickData[0];
            
            const currentPrice = currentCandle.c;
            const openPrice = firstCandle.o;
            const change = currentPrice - openPrice;
            const changePercent = ((change / openPrice) * 100).toFixed(2);

            document.getElementById('currentPrice').textContent = currentPrice.toFixed(2);
            
            const changeEl = document.getElementById('priceChange');
            const changeClass = change >= 0 ? 'green' : 'red';
            changeEl.innerHTML = `<span class="${changeClass}">${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent}%)</span>`;

            const allPrices = candlestickData.flatMap(c => [c.h, c.l]);
            const high = Math.max(...allPrices);
            const low = Math.min(...allPrices);

            document.getElementById('highPrice').textContent = high.toFixed(2);
            document.getElementById('lowPrice').textContent = low.toFixed(2);
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function updateStatus(type, message) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status ${type}`;
            statusEl.textContent = message;
        }

        // ============================================
        // CHART CONTROLS
        // ============================================
        
        function startChart() {
            symbol = document.getElementById('symbol').value;
            timeframe = parseInt(document.getElementById('timeframe').value);
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            candlestickData = [];
            currentCandle = null;
            scrollOffset = 0;
            autoScroll = true;
            
            updateStatus('loading', 'üì° Connecting...');
            connectWebSocket();
            isConnected = true;

            if (!patternAnalyzer) {
                patternAnalyzer = new PatternAnalyzer();
                const container = document.getElementById('threejsContainer');
                patternAnalyzer.initThreeJS(container);
                
                window.onPatternDetected = function(pattern) {
                    displayPattern(pattern);
                };
            }
        }

        function stopChart() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            isConnected = false;
            updateStatus('disconnected', '‚è∏Ô∏è Chart stopped');
        }

        // ============================================
        // PATTERN DISPLAY
        // ============================================
        
        function displayPattern(pattern) {
            const container = document.getElementById('patternsContainer');
            
            if (container.querySelector('.no-patterns')) {
                container.innerHTML = '';
            }

            const highConfBadge = pattern.confidence >= 85 ? 
                `<span class="alert-badge">üî• HIGH CONFIDENCE</span>` : '';

            const card = document.createElement('div');
            card.className = `pattern-card ${pattern.bias}`;
            card.innerHTML = `
                <div class="pattern-name">
                    ${getBiasIcon(pattern.bias)} ${pattern.name}
                    <span class="pattern-timeframe">${getTimeframeLabel(pattern.timeframe)}</span>
                    ${highConfBadge}
                </div>
                <div class="pattern-details">
                    <div class="pattern-row">
                        <span class="pattern-label">Current Price</span>
                        <span class="pattern-value">${pattern.currentPrice}</span>
                    </div>
                    <div class="pattern-row">
                        <span class="pattern-label">Entry Price</span>
                        <span class="pattern-value">${pattern.entry}</span>
                    </div>
                    <div class="pattern-row">
                        <span class="pattern-label">TP1 (Conservative)</span>
                        <span class="pattern-value" style="color: #10b981;">üéØ ${pattern.tp1}</span>
                    </div>
                    <div class="pattern-row">
                        <span class="pattern-label">TP2 (Moderate)</span>
                        <span class="pattern-value" style="color: #10b981;">üéØ ${pattern.tp2}</span>
                    </div>
                    <div class="pattern-row">
                        <span class="pattern-label">TP3 (Aggressive)</span>
                        <span class="pattern-value" style="color: #10b981;">üéØ ${pattern.tp3}</span>
                    </div>
                    <div class="pattern-row">
                        <span class="pattern-label">Stop Loss</span>
                        <span class="pattern-value" style="color: #ef4444;">üõë ${pattern.sl}</span>
                    </div>
                    <div class="pattern-row">
                        <span class="pattern-label">Signal</span>
                        <span class="pattern-value">${pattern.bias.toUpperCase()}</span>
                    </div>
                </div>
                <div class="confidence-bar">
                    <div class="confidence-fill" style="width: ${pattern.confidence}%"></div>
                </div>
                <div style="text-align: center; margin-top: 8px; font-size: 0.9em; opacity: 0.9;">
                    Confidence: ${pattern.confidence}%
                </div>
            `;

            container.insertBefore(card, container.firstChild);

            while (container.children.length > 6) {
                container.removeChild(container.lastChild);
            }

            if (pattern.confidence >= 85) {
                playNotificationSound();
            }
        }

        function getBiasIcon(bias) {
            switch(bias) {
                case 'bullish': return 'üìà';
                case 'bearish': return 'üìâ';
                default: return 'üìä';
            }
        }

        function getTimeframeLabel(tf) {
            switch(tf) {
                case 60: return '1M';
                case 120: return '2M';
                case 300: return '5M';
                case 900: return '15M';
                case 1800: return '30M';
                case 3600: return '1H';
                default: return `${tf}s`;
            }
        }

        function playNotificationSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // ============================================
        // EVENT LISTENERS & INITIALIZATION
        // ============================================
        
        document.getElementById('symbol').addEventListener('change', () => {
            if (isConnected) {
                startChart();
            }
        });

        document.getElementById('timeframe').addEventListener('change', () => {
            if (isConnected) {
                startChart();
            }
        });

        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('‚úÖ Notifications enabled');
                }
            });
        }

        // Clean old patterns
        setInterval(() => {
            if (patternAnalyzer) {
                patternAnalyzer.clearOldPatterns();
            }
        }, 60000);

        // Auto-start on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                initCanvas();
                updateZoomDisplay();
                startChart();
                console.log('üöÄ Auto-started chart with pattern detection');
            }, 500);
        });
    </script>
</body>
</html>
